# 2장 인덱스 기본

## 2.2 인덱스 기본 사용법
- 인덱스 기본 사용법은 인덱스를 Range Scan 하는 방법을 의미
<br>

> ### 2.21 인덱스를 사용한다는 것
- 인덱스 컬럼(선두 컬럼)을 가공하지 않아야 인덱스를 사용할 수 있다.  

#### "인덱스를 정상적으로 사용한다"의 의미
- 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미
- 즉, 리프 블록 일부만 스캔하는 Index Range Scan을 의미(인덱스를 가공하면 시작점을 찾을 수 없어서 Index Full Scan 방식으로 작동)
<br>

> ### 2.22 인덱스를 RangeScan 할 수 없는 이유
- 인덱스 칼럼을 가공해서 사용하게되면, 인덱스 스캔 시작점을 찾을 수 없기 때문에 정상적으로 사용할 수 없다.  
```sql
인덱스 스캔 시작점을 찾을 수 없는 예

where substr(생년월일, 5, 2) = '05' -- 년도가 없어 전체 스캔
where nvl(주문수량, 0) < 100 -- null 값을 대상으로 조건을 걸었음
where 업체명 like '%대한%' -- 대한을 포함하는 값 전체를 스캔해야 함
where (전화번호 = :tel_no OR 고객명 = :cust_nm) -- 옵티마이저가 IN-List Iterator를 사용하기 때문에 개수만큼 Index Range Scan을 반복한다
where 전화번호 in ( :tel_no1, :tel_no2 ) -- 이 경우는 각각 인덱스를 걸어서 UNION ALL 방식을 사용
-- IN 조건절은 OR을 표현하는 다른 방법
```
- OR 또는 IN 조건절은 옵티마이저의 쿼리 변환 기능을 통해 Index Range Scan으로 처리되기도 함
<br>

> ### 2.23 더 중요한 인덱스 사용 조건
- 인덱스 선두 컬럼이 조건절에 있어야 함(가공하지 않은 상태로)   
*인덱스 선두컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능*  
- 인덱스를 잘 타는지(인덱스 Range Scan을 하는지)는 리프 블록에서 스캔하는 양을 꼭 확인해봐야 함( AND 조건절에 가공값을 넣어 전체 스캔하고 있을지도 모르기 때문)
```sql
인덱스는 잘 타지만 효율적이지 못한 예

SELECT *
FROM 주문상품
WHERE 주문일자 = ord_dt
    AND 상품번호 LIKE '%PING%'
```
<br>

> ### 2.24 인덱스를 이용한 소트 연산 생략
- 인덱스가 정렬화 되어 있기 때문에 Range Scan이 가능한 거고, 소트 연산 생략 효과도 부수적으로 얻게 됨
- PK 인덱스에서 이미 순서대로 정렬되어 있는 경우는 옵티마이저가 ORDER BY가 있는 경우임에도 따로 수행하지 않을 수도 있음
- 오름차순 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색 후 우측으로 수평적 탐색
- 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색 후 좌측으로 수평적 탐색
<br>

> ### 2.25,6 ORDER BY,SELECT-LIST 절에서 컬럼 가공
- ORDER BY 절과 SELECT-LIST(SELECT절에 나열된 컬럼들)에서 컬럼을 가공하면 성능상 문제가 생길 수도 있음(불필요한 소트 연산 등)
<br>

> ### 2.27 자동 형변환
#### 서로 다른형이 만났을 때
  - 숫자형과 문자형이 만나면 숫자형이 이긴다.
  - 날짜형과 문자형이 만나면 날짜형이 이긴다.
  - 연산자가 LIKE일 때는 문자형이 숫자형을 이긴다.  
  
  *"이긴다"는 이긴 형으로 형변환을 진행한다는 뜻*

- 자동 형변환 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환해 주어야 함
- TO_CHAR, TO_DATE, TO_NUMBER 같은 형변환 함수를 의도적으로 생략하곤 하지만, 성능을 위해서는 블록 I/O가 중요하기 때문에 써야할 땐 쓰는게 더 이로움(형변환 함수를 생략한다고 해서 연산 횟수가 주는 것도 아님)


## 2.3 인덱스 확장기능 사용법

> ### 2.31 Index Range Scan
- B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식
- 리프 블록까지 수직적으로 탐색한 후 "필요한 범위"만 스캔
- 성능은 인덱스 스캔 범위, 테이블 액세스 횟수를 얼마나 줄일 수 있느냐로 결정
<br>

> ### 2.32 Index Full Scan
- 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
- 대개 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택됨
<br>

#### Index Full Scan의 효용성
- 인덱스 선두 컬럼이 조건절에 없으면 옵티마이저는 먼저 Table Full Scan을 고려
- 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스하는 상황이라면, 면적이 큰 테이블보다 인덱스를 스캔하는 쪽이 유리
- 이럴 때 옵티마이저는 Index Full Scan 방식을 선택

#### 인덱스를 이용한 소트 연산 생략
- first_rows 힌트를 사용하면 소트 연산을 생략함으로써 전체 집합 중 처음 일부를 빠르게 출력할 목적으로 옵티마이저가 Index Full Scan 방식을 선택
- 주의할 것은, 처음 의도(부분범위 처리 활용)와 달리 fetch를 멈추지 않고 데이터를 끝까지 읽는다면 Table Full Scan 보다 훨씬 더 많은 I/O를 일으킴
<br>

> ### 2.33 Index Unique Scan
- 수직적 탐색만으로 데이터를 찾는 스캔 방식으로서, Unique 인덱스를 '=' 조건으로 탐색하는 경우에 작동
- Unique 인덱스라고 해도 범위검색 조건(between,부등호,like)이나 Unique 결합 인덱스에 대해 일부 컬럼만으로 검색할 때는 Index Range Scan으로 처리

> ### 2.34 Index Skip Scan
- 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 '가능성이 있는' 리프 블록만 골라서 액세스하는 스캔 방식
- 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용
- Index Range Scan이 불가능하거나 효율적이지 못한 상황에서 Index Skip Scan이 종종 빛을 발한다. 부분범위 처리가 가능하다면 Index Full Scan이 도움이 되기도 함
- 인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 하며, 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때 이들 스캔 방식을 차선책으로 활용하는 전략이 바람직 함
<br>

> ### 2.35 Index Fast Full Scan
- 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔
- 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과를 발휘(관련 힌트는 index_ffs, no_index_ffs)

#### 특징
- 속도는 빠르지만, 인덱스 리프 노드가 갖는 연결 리스트 구조를 무시한 채 데이터를 읽기 때문에 결과집합이 인덱스 키 순서대로 정렬되지 않음.
- 쿼리에 사용한 컬림이 모두 인덱스에 포함돼 있을 때만 사용할 수 있음
- 인덱스가 파티션 돼 있지 않더라도 병렬 쿼리가 가능. 병렬 쿼리 시에는 Direct Path I/O 방식을 사용하기 때문에 I/O 속도가 더 빨라짐

|번호|Index Full Scan|Index Fast Full Scan|
|:------:|:------:|:------:|
|1|인덱스 구조를 따라 스캔|세그먼트 전체를 스캔|
|2|결과집합 순서 보장|결과집합 순서 보장 안 됨|
|3|Single Block I/O|Multiblock I/O|
|4|(파티션 돼 있지 않다면) 병렬스캔 불가|병렬스캔 가능|
|5|인덱스에 포함되지 않은 컬럼 조회 시에도 사용 가능|인덱스에 포함된 컬럼으로만 조회할 때 사용 가능|
<br>

> ### 2.36 Index Range Scan Descending
- Index Range Scan과 기본적으로 동일한 스캔 방식이다. 인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과집합을 얻는다는 점만 다름
- 만약 옵티마이저가 인덱스를 거꾸로 읽지 않는다면, index_desc 힌트를 이용해 유도할 수 있음
- MAX 값을 구하고자 할 때도 해당 컬럼에 인덱스가 있으면 인덱스를 뒤에서부터 한 건만 읽고 멈추는 실행계획이 자동으로 수립
