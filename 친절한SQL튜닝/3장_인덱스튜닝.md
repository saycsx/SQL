# 인덱스 튜닝

## 3.1 테이블 액세스 최소화

> ### 3.11 테이블 랜덤 액세스
#### 인덱스 ROWID는 논리적 주소
- 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담음(디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다)
- 프로그래밍 언어에서 포인터는 메모리 주소값을 담는 변수를 말함

#### 메인 메모리 DB와 비교
- 오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조
- 메모리 주소 정보(포인터)가 아닌 디스크 주소 정보(DBA)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아감

#### I/O 메커니즘 복습
- 블록을 읽을 때는 디스크로 가기 전에 버퍼캐시부터 찾음. 읽고자 하는 DBA를 해시 함수에 입력해서 해시 체인을 찾고 거기서 버퍼 헤더를 찾음
- 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 찾아감
- 테이블을 Full Scan 할 때는 익스텐트 맵을 통해 읽을 블록들의 DBA 정보를 얻음
- 인덱스로 테이블 블록을 액세스할 때는 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보를 얻음
- 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 반복해야 함. 동시 액세스가 심할 때는 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생함
- 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조

> ### 3.12 인덱스 클러스터링 팩터

#### 클러스터링 팩터(CF)
- 군집성 계수. 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미
- 데이터량이 많으면 데이터가 뿔뿔히 흩어져 있어서 CF가 좋지 않음

#### 버퍼 Pinning
- 오라클은 래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 포인터를 유지하는데 이를 '버퍼 Pinning'이라고 부름

##### CF가 좋은 컬럼에 생선한 인덱스는 테이블 액세스량에 비해 블록 I/O가 절게 발생하기 떄문에 검색 효율이 매우 좋음

> ### 3.13 인덱스 손익분기점
- 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조. 따라서 읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려짐
- 인덱스 손익분기점은 보통 5~20%의 낮은 수준에서 결정( 5~20% 수준의 손익분기점은 10만 건 이내, 많아봐야 100만 이내 테이블에 적용되는 수치. 더 큰 테이블에선 더 낮아짐)
- CF에 따라 크게 달라지는데, CF가 나쁘면 손익분기점은 5% 미만에서 결정되며, 심할 때는(BCHR이 매우 안 좋을 때) 1% 미만으로 낮아짐
- 반대로 CF가 아주 좋을 때(인위적으로 전체 데이터를 인덱스 컬럼 순으로 정렬해서 재입력했을 때)는 손익분기점이 90% 수준까지 올라가기도 함

#### 인덱스 손익분기점
- Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점

#### 인덱스를 이용한 테이블 액세스가 Table Full Scan보다 더 느려지게 만드는 가장 핵심적인 요인
- Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
- Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식

#### 인덱스 손익분기점과 버퍼캐시 히트율
- 버퍼캐시는 요즘 기준으로 보통 수백만개 블록을 캐싱하는 수준이다. 따라서 특정 인덱스로 100만 건 이상 액세스한다면 캐시 히트율은 극히 낮을 수 밖에 없음
- 1000만 건 정도 테이블이면 인덱스 컬럼 기준으로 값이 같은 테이블 레코드가 근처에 모여 있을 가능성이 매우 작음.인덱스를 스캔하면서 읽은 테이블 블록을 뒤에서 다시 읽을 가능성이 작기 때문에 거의 모든 데이터를 디스크에서 읽게 되므로, 이런 상황이면 손익분기점 자체가 의미 없어진다.
- 만 건만 넘어도 Table Full Scan 방식으로 읽는 게 빠를 수 있다.

#### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝 ***
- 온라인 프로그램
  - 보통 소량 데이터를 읽고 갱신
  - 인덱스 사용과 NL조인이 유리
  - 인덱스를 이용해 소트 연산을 생략함으로써 부분범위 처리 방식으로 구현할 수 있다면, 대량 데이터 조회도 빠르게 할 수 있음

- 배치 프로그램
  - 항상 전체범위 처리 기준으로 튜닝
  - Full Sacn과 해시 조인이 유리
  - 초대용량 테이블을 Full Sacn하면 상당히 오래 걸림
    - 배치 프로그램에서는 파티션 활용 전략이 매우 중요한 튜닝 요소이고, 병렬 처리까지 더할 수 있다면 금상첨화
    - 성능 측면에서만 보면 테이블을 파티셔닝하는 이유는 결국 Full Scan을 빠르게 처리하기 위해서임

- 모든 성능 문제를 인덱스로 해결하려해선 안됨. 인덱스는 다양한 튜닝 도구 중 하나일 뿐이며, 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾고자 할 때 주로 사용

> ### 3.13 인덱스 컬럼 추가

- ㅌ이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는 것
- 인덱스 스캔량은 줄지 않지만, 테이블 랜덤 액세스 횟수를 줄여줌

> ### 3.14 인덱스만 읽고 처리

#### Covered 쿼리
- 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 했을 때, 인덱스만 읽어서 처리하는 쿼리
- 효과는 매우 좋지만, 추가해야 할 컬럼이 많을 경우 실제 적용하기 곤란한 경우도 많음

#### Include 인덱스
- 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
- 순전히 테이블 랜덤 액세스를 줄이는 용도로 개발

> ### 3.15 인덱스 구조 테이블

- 테이블을 인덱스 구조로 만드는 구문
```sql
create table index_org_t ( a number, b varchar(10), constraint index_org_t_pk primary key (a) )
organization index ;
```
#### IOT (Index-Organized Table)
- 랜덤 액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성한 것
- 테이블을 찾아가기 위한 ROWID를 갖는 일반 인덱스와 달리 IOT는 그 자리에 테이블 데이터를 갖음
- 즉, 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장하고 있음
- 일반 테이블은 '힙 구조 테이블'로 순서 없이 데이터를 입력하지만, IOT는 정렬 상태를 유지하며 입력함
- IOT는 인위적으로 CF를 좋게 만드는 방법 중 하나. 같은 값을 가진 레코드들이 100% 정렬된 상태로 모여 있으므로 시퀀셜 방식으로 데이터를 액세스. 이 때문에 BETWEEN이나 부등호 조건으로 넓은 범위를 읽을 때 유리.

> ### 3.16 클러스터 테이블
- 클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지

#### 인덱스 클러스터 테이블
- 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조다.
- 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결한다.
- 여러 테이블 레코드를 같은 블록에 저장할 수도 있다.

- 인덱스 클러스터 테이블 구성
```sql
-- 먼저 아래와 같이 클러스터를 생성한다.
create cluster c_dept# ( deptno number(2) ) index ;

-- 그리고 클러스터에 테이블을 담기 전에 아래와 같이 클러스터 인덱스를 반드시 정의해야 한다. 
-- 왜냐하면, 클러스터 인덱스는 데이터 검색 용도로 사용할 뿐만 아니라 데이터가 저장될 위치를 찾을 때도 사용하기 띠문이다.
create index c_dept#_idx on cluster c_dept#;

-- 클러스터 인덱스를 만들었으면 아래와 같이 클러스터 테이블을 생성한다.
create table dept (
  deptno number(2)    not null
, dname  varchar2(4)  not null
, loc    varchar2(13) )
cluster c_dept#( deptno );
```

- 클러스터 인덱스도 일반 B*Tree 인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다는 점이 다름
- 클러스터 인덱스는 테이블 레코드와 1:M 관계
- 이런 구조적 특성 떄문에 클러스터 인덱스를 스캔하면서 값을 찾을 때는 랜덤 액세스가 값 하나당 한 번씩 밖에 발생하지 않음
- 클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다는 게 핵심 원리

#### 해시 클러스터 테이블
- 해시 클러스터는 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다름
- 해시 클러스터 테이블 구성
```sql
-- 먼저 클러스터를 생성하고 위에서 했던 것처럼 클러스터 테이블을 생성한다.
create cluster c_dept# ( deptno number(2) ) hashkeys 4 ;
```

## 3.2 부분범위 처리 활용

> ### 3.21 부분범위 처리
- 전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고, 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것

#### 정렬 조건이 있을 때 부분범위 처리
- DB 서버는 '모든' 데이터를 다 읽어 created 순으로 정렬을 마치고서야 클라이언트에게 데이터 전송을 시작할 수 있음
- 다행히 created 컬럼이 선두인 인덱스가 있으면, 부분범위 처리가 가능

#### Array Size 조정을 통한 Fetch Call 최소화
- 전송해야 할 데이터량에 따라 Array Size를 조절할 필요가 있음

> ### 3.22 부분범위 처리 구현
- 출력 레코드 수가 Array Size에 도달하면 멈추었다가 사용자 요청이 있을 때 다시 데이터를 Fetch하도록 하는 코드를 직접 구현할 수도 있지만, 보통 개발 프레임워크에 미리 구현돼있는 기능을 활용한다.

> ### 3.33 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
- OLTP성 업무에서 쿼리 결과 집합이 아주 많을 때 사용자는 특정한 정렬 순서로 상위 일부 데이터만 확인. 이럴 때, 항상 정렬 상태를 유지하는 인덱스를 이용하면, 정렬 작업을 생략하고 앞쪽 일부 데이터를 아주 빠르게 보여줄 수 있음
#### 멈출 수 있어야 의미있는 부분범위 처리
- 문제는 앞쪽 일부만 출력하고 멈출 수 있는가이다. 이것이 부분범위 처리의 핵심이다.
- 2-Tier 환경에서는 이렇게 구현할 수 있지만 n-Tier 아키텍처에서는 클라이언트가 특정 DB 커넥션을 독점할 수 없다.
- 단위 작업을 마치면 DB 커넥션을 곧바로 커넥션 풀에 반환해야 하므로 그 전에 SQL 조회 결과를 클라이언트에게 '모두' 전송하고 커서를 닫아야 한다.
- 자세한 내용은 5.3 참고

#### 배치 I/O
- 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능
- 인덱스를 이용해 테이블을 액세스하다가 버퍼 캐시에서 블록을 찾지 못하면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리한다.
