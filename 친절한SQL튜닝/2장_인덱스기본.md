# 2장 인덱스 기본

## 2.2 인덱스 기본 사용법
- 인덱스 기본 사용법은 인덱스를 Range Scan 하는 방법을 의미
<br>

> ### 2.21 인덱스를 사용한다는 것
- 인덱스 컬럼(선두 컬럼)을 가공하지 않아야 인덱스를 사용할 수 있다.  

#### "인덱스를 정상적으로 사용한다"의 의미
- 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미
- 즉, 리프 블록 일부만 스캔하는 Index Range Scan을 의미(인덱스를 가공하면 시작점을 찾을 수 없어서 Index Full Scan 방식으로 작동)
<br>

> ### 2.22 인덱스를 RangeScan 할 수 없는 이유
- 인덱스 칼럼을 가공해서 사용하게되면, 인덱스 스캔 시작점을 찾을 수 없기 때문에 정상적으로 사용할 수 없다.  
```sql
인덱스 스캔 시작점을 찾을 수 없는 예
where substr(생년월일, 5, 2) = '05' -- 년도가 없어 전체 스캔
where nvl(주문수량, 0) < 100 -- null 값을 대상으로 조건을 걸었음
where 업체명 like '%대한%' -- 대한을 포함하는 값은 전체를 스캔해야 함
where (전화번호 = :tel_no OR 고객명 = :cust_nm) -- 옵티마이저가 IN-List Iterator를 사용하기 때문에 개수만큼 Index Range Scan을 반복한다
where 전화번호 in ( :tel_no1, :tel_no2 ) -- 이 경우는 각각 인덱스를 걸어서 UNION ALL 방식을 사용
-- IN 조건절은 OR을 표현하는 다른 방법
```
- OR 또는 IN 조건절은 옵티마이저의 쿼리 변환 기능을 통해 Index Range Scan으로 처리되기도 함
<br>

> ### 2.23 더 중요한 인덱스 사용 조건
- 인덱스 선두 컬럼이 조건절에 있어야 함(가공하지 않은 상태로)   
*인덱스 선두컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능*  
- 인덱스를 잘 타는지(인덱스 Range Scan을 하는지)는 리프 블록에서 스캔하는 양을 꼭 확인해봐야 함( AND 조건절에 가공값을 넣어 전체 스캔하고 있을지도 모르기 때문)
```sql
SELECT *
FROM 주문상품
WHERE 주문일자 = ord_dt
    AND 상품번호 LIKE '%PING%'
```
<br>

> ### 2.24 인덱스를 이용한 소트 연산 생략
- 인덱스가 정렬화 되어 있기 때문에 Range Scan이 가능한 거고, 소트 연산 생략 효과도 부수적으로 얻게 됨
- PK 인덱스에서 이미 순서대로 정렬되어 있는 경우는 옵티마이저가 ORDER BY가 있는 경우임에도 따로 수행하지 않을 수도 있음
- 오름차순 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색 후 우측으로 수평적 탐색
- 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색 후 좌측으로 수평적 탐색
<br>

> ### 2.25,6 ORDER BY,SELECT-LIST 절에서 컬럼 가공
- ORDER BY 절과 SELECT-LIST(SELECT절에 나열된 컬럼들)에서 컬럼을 가공하면 성능상 문제가 생길 수도 있음(불필요한 소트 연산 등)
<br>

> ### 2.27 자동 형변환
#### 서로 다른형이 만났을 때
  - 숫자형과 문자형이 만나면 숫자형이 이긴다.
  - 날짜형과 문자형이 만나면 날짜형이 이긴다.
  - 연산자가 LIKE일 때는 문자형이 숫자형을 이긴다.  
  
  *"이긴다"는 이긴 형으로 형변환을 진행한다는 뜻*

- 자동 형변환 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환해 주어야 함
- TO_CHAR, TO_DATE, TO_NUMBER 같은 형변환 함수를 의도적으로 생략하곤 하지만, 성능을 위해서는 블록 I/O가 중요하기 때문에 써야할 땐 쓰는게 더 이로움(형변환 함수를 생략한다고 해서 연산 횟수가 주는 것도 아님)
